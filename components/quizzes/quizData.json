{
  "courses": {
    "avalanche-fundamentals": {
      "title": "Avalanche Fundamentals",
      "quizzes": ["101", "102", "103", "104", "105", "106", "107", "108", "109", "110", "111", "112", "113", "114", "115", "116", "117"]
    },
    "l1-tokenomics": {
      "title": "L1 Tokenomics",
      "quizzes": ["201", "202", "203", "204", "205", "206", "207", "208", "209"]
    },
    "interchain-token-transfer": {
      "title": "Interchain Token Transfer",
      "quizzes": ["118", "119", "120", "121", "122", "123", "124", "125", "126", "127"]
    },
    "interchain-messaging": {
      "title": "Interchain Messaging",
      "quizzes": ["301", "302", "303", "304", "305", "306", "307", "308", "309", "310", "311", "312", "313", "314", "315", "316"]
    }
  },
  "quizzes": {
    "101": {
      "question": "What is the underlying principle of the Avalanche Consensus family?",
      "options": [
        "Repeated Sub-Sampling",
        "Centralized Election",
        "Randomly choosing a Validator that decides on the next State",
        "Proof of Work"
      ],
      "correctAnswers": [0],
      "hint": "Think about how Avalanche Consensus achieves consensus.",
      "explanation": "The underlying principle of the Avalanche Consensus family is Repeated Sub-Sampling. This means that validators repeatedly sample the network to reach consensus.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "102": {
      "question": "What is the role of validators in the event of conflicting transactions?",
      "options": [
        "Validators choose the transaction that benefits them the most.",
        "Validators automatically reject all conflicting transactions.",
        "Validators collectively decide on which of the two conflicting transactions will be accepted by all validators and determine the next state.",
        "Validators create a new transaction to resolve the conflict."
      ],
      "correctAnswers": [2],
      "hint": "Think about how validators resolve conflicts in a blockchain network.",
      "explanation": "In the event of conflicting transactions, validators have to collectively decide on which of the two conflicting transactions will be accepted by all validators and determine the next state. They do not act based on personal benefits, they don't reject all conflicting transactions, and they don't create new transactions to resolve conflicts.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "103": {
      "question": "What is a Double Spending Attack in the context of blockchain?",
      "options": [
        "It is when a user attempts to spend more cryptocurrency than they own by creating multiple transactions that reference the same funds.",
        "It is when a user tries to double the amount of cryptocurrency they own through fraudulent transactions.",
        "It is when a user performs two transactions at the exact same time to exploit the system.",
        "It is when a validator duplicates transactions to increase their validation rewards."
      ],
      "correctAnswers": [0],
      "hint": "Think about how a user would attempt to spend more funds than they hold.",
      "explanation": "A Double Spending Attack is when a user attempts to spend more cryptocurrency than they own by creating multiple transactions that reference the same funds. This kind of attack is a threat to the integrity of the blockchain system.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "104": {
      "question": "In the Avalanche Consensus protocol, what determines whether a validator changes its preference?",
      "options": [
        "A simple majority of sampled validators",
        "An α-majority of sampled validators",
        "A unanimous decision from sampled validators",
        "The validator's initial random choice"
      ],
      "correctAnswers": [1],
      "hint": "Think about the concept of 'α-majority' mentioned in the chapter.",
      "explanation": "Avalanche consensus dictates that a validator changes its preference if an α-majority of the sampled validators agrees on another option. The α-majority is a key concept in the protocol, allowing for flexible decision-making based on the sampled subset of validators.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "105": {
      "question": "When does a validator in Avalanche finalize its decision?",
      "options": [
        "After a set number of rounds of querying and getting majority consensus.",
        "After the preference is confirmed by the α-majority for β (Decision Threshold) consecutive rounds.",
        "As soon as a conflict between transactions arises.",
        "When all validators in the system have replied with their preference."
      ],
      "correctAnswers": [1],
      "hint": "Think about the process of finalizing a decision in Avalanche Consensus.",
      "explanation": "In Avalanche, a validator finalizes its decision after its preference is confirmed by the α-majority for β (Decision Threshold) consecutive rounds. It's not a single round process, it doesn't happen immediately when a conflict arises, and it doesn't require replies from all validators in the system.",
      "chapter": "Primer on Avalanche Consensus"
    },
    "106": {
      "question": "What is the primary purpose of an L1 within the Avalanche network?",
      "options": [
        "Increasing token value",
        "Mining cryptocurrency",
        "Enabling specialized blockchain use cases"
      ],
      "correctAnswers": [2],
      "hint": "Think about how L1s are designed to be customizable and optimized for specific use cases.",
      "explanation": "The primary purpose of an L1 within the Avalanche network is to enable specialized blockchain use cases. Each L1 is designed to be optimized for specific use cases, thereby boosting the network's overall performance.",
      "chapter": "Multi-Chain Architecture"
    },
    "107": {
      "question": "The addition of a new decentralized application (dApp) on a single-chain system causes more competition over the block space of that chain.",
      "options": [
        "True",
        "False"
      ],
      "correctAnswers": [0],
      "hint": "Think about how each new dApp vies for the same block space in a single-chain system.",
      "explanation": "Each new dApp vies for the same block space in a single-chain system, leading to unnecessary overcrowding of the chain. Multi-chain systems alleviate this issue.",
      "chapter": "Multi-Chain Architecture"
    },
    "108": {
      "question": "In case of a security breach on the Ethereum mainnet, all Layer 2 solutions are potentially affected.",
      "options": [
        "True",
        "False"
      ],
      "correctAnswers": [0],
      "hint": "Think about how Layer 2 solutions delegate security to the Ethereum mainnet.",
      "explanation": "Layer 2 solutions delegate security to the Ethereum mainnet. Hence, a security breach on the mainnet could potentially affect all Layer 2 solutions.",
      "chapter": "Multi-Chain Architecture"
    },
    "109": {
      "question": "In the soda dispenser analogy, what does the 'state' of the machine represent? (Select all that apply)",
      "options": [
        "The soda flavors",
        "The current balance",
        "The number of cans available per flavor",
        "The location of the machine"
      ],
      "correctAnswers": [1, 2],
      "hint": "Think about what information the machine needs to keep track of to function properly.",
      "explanation": "In the soda dispenser analogy, the 'state' of the machine represents the current balance, total revenue, and the number of cans available per brand.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "110": {
      "question": "In the soda dispenser analogy, what of the following are operations of the machine? (Select all that apply)",
      "options": [
        "Inserting coins",
        "The current balance",
        "The location of the machine",
        "Selecting a soda flavour"
      ],
      "correctAnswers": [0, 3],
      "hint": "Think about what actions a user can take when interacting with the machine.",
      "explanation": "In the soda dispenser analogy, the operations of the machine include inserting coins and selecting a soda flavor.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "111": {
      "question": "What are the advantages of implementing state machines? (Select all that apply)",
      "options": [
        "Increased network speed",
        "Decreased transaction costs",
        "Reproducibility",
        "Clear interface"
      ],
      "correctAnswers": [2, 3],
      "hint": "Think about how state machines simplify interactions and ensure consistency.",
      "explanation": "State machines, like the virtual machines in a blockchain, have a clear interface that makes it straightforward to interact with them. They are also reproducible, meaning multiple identical instances can be created.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "112": {
      "question": "In blockchain systems, what role do validators play? (Select all that apply)",
      "options": [
        "They reach consensus on the sequence in which transactions are carried out",
        "They determine the prices of the digital assets",
        "They regulate the blockchain's electricity usage",
        "They operate one or more instances of the virtual machines"
      ],
      "correctAnswers": [0, 3],
      "hint": "Think about the role validators play in maintaining the blockchain's integrity.",
      "explanation": "Validators in blockchain systems operate one or more instances of virtual machines and reach consensus on the sequence in which transactions are carried out.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "113": {
      "question": "How do the validators make sure that they all have the same view on the state?",
      "options": [
        "By assigning each validator a unique part of the blockchain to monitor",
        "Through the execution of operations on the local instance of the VM by all validators in the same order",
        "Through the manual checking of each transaction by a centralized authority"
      ],
      "correctAnswers": [1],
      "hint": "Think about how validators ensure that they all have the same view of the blockchain's state.",
      "explanation": "Validators ensure they all have the same view on the state by executing operations on their local instance of the VM in the same order. This ensures consistency across the network.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "114": {
      "question": "What is a Virtual Machine (VM) in the context of blockchain?",
      "options": [
        "A decentralized computer that can execute a program in a controlled environment",
        "A physical machine that runs a blockchain network",
        "A machine that dispenses soda"
      ],
      "correctAnswers": [0],
      "hint": "Think about how a VM operates in a blockchain system.",
      "explanation": "A Virtual Machine (VM) in the context of blockchain is like a decentralized computer that can execute a program in a controlled environment. It defines the application-level logic of a blockchain.",
      "chapter": "Virtual Machines & Blockchains"
    },
    "115": {
      "question": "How many VMs can Avalanche run?",
      "options": [
        "Only the Avalanche Virtual Machine",
        "EVM and AVM",
        "There is no limit to how many virtual machines can run on Avalanche. Everyone can create a modified VM catering best to their needs"
      ],
      "correctAnswers": [2],
      "hint": "Think about the flexibility of Avalanche's architecture.",
      "explanation": "Avalanche is designed to be highly flexible, allowing for an unlimited number of custom Virtual Machines to be created and run on the network.",
      "chapter": "Virtual Machine Customization"
    },
    "116": {
      "question": "Can a Virtual Machine (VM) be used to create multiple blockchains?",
      "options": [
        "Yes, the same VM can be used to create multiple blockchains",
        "No, each blockchain requires a unique VM",
        "Yes, but only if the blockchains are part of different networks"
      ],
      "correctAnswers": [0],
      "hint": "Think about how a VM can be customized to create different blockchains.",
      "explanation": "You can think of a Virtual Machine (VM) as a blueprint for a blockchain, where the same VM can be used to create multiple blockchains. Each of these blockchains adheres to the same rules but remains logically independent from the others.",
      "chapter": "Virtual Machine Customization"
    },
    "117": {
      "question": "How does Avalanche handle the modification of Virtual Machines (VMs)?",
      "options": [
        "Customization is challenging and requires a wide consensus among network participants.",
        "Customization is not allowed as it can compromise the security of the blockchain.",
        "Avalanche offers an easy API for VM developers.",
        "Avalanche does not support customization of VMs."
      ],
      "correctAnswers": [2],
      "hint": "Think about how Avalanche allows developers to modify Virtual Machines.",
      "explanation": "Unlike one-chain-fits all systems, which requires a wide consensus to make changes, Avalanche allows for straightforward customization of Virtual Machines, making it more adaptable to unique use cases.",
      "chapter": "Virtual Machine Customization"
    },
    "118": {
      "question": "Which of the following best describes the role of a native token in an EVM-based blockchain?",
      "options": [
        "It is used only for staking and governance within the blockchain.",
        "It serves as both a means of value transfer and as the gas token for executing transactions and smart contracts.",
        "It is used exclusively for purchasing NFTs on the blockchain.",
        "It has no functional role other than being a store of value."
      ],
      "correctAnswers": [1],
      "hint": "Consider both value transfer and execution costs in the network.",
      "explanation": "In an EVM-based blockchain, the native token serves as both a means of value transfer within the network and as the gas token for executing transfers or smart contracts. Some blockchains optionally choose to also use the native token as their staking and governance token.",
      "chapter": "Interchain Token Transfer"
    },
    "119": {
      "question": "What is the purpose of marking a function as 'payable' in Solidity?",
      "options": [
        "It allows the function to receive ERC-20 tokens.",
        "It enables the function to execute without gas fees.",
        "It allows the function to receive native blockchain tokens.",
        "It prevents the function from modifying state variables."
      ],
      "correctAnswers": [2],
      "hint": "Think about how functions handle incoming funds.",
      "explanation": "In Solidity, marking a function as 'payable' allows it to accept native blockchain tokens like ETH or AVAX. Without 'payable', the function cannot receive native tokens.",
      "chapter": "Interchain Token Transfer"
    },
    "120": {
      "question": "What is the purpose of the `approve()` function in the ERC-20 token standard?",
      "options": [
        "It allows an address to transfer tokens to another address directly.",
        "It grants an allowance for another account to spend the balance of an account.",
        "It returns the total supply of the token.",
        "It checks the balance of a specific address."
      ],
      "correctAnswers": [1],
      "hint": "Consider how a spender gets permission to spend tokens from an owner's account.",
      "explanation": "The `approve()` function allows an owner to authorize a spender to withdraw tokens from the owner's account, up to a specified limit, enabling the spender to use `transferFrom()` to transfer tokens.",
      "chapter": "Interchain Token Transfer"
    },
    "121": {
      "question": "Why is it necessary to call the `approve()` function before transferring ERC-20 tokens to a smart contract?",
      "options": [
        "Because it sets the gas fee for the transaction.",
        "It is not necessary; tokens can be transferred without approval.",
        "To check the balance of the smart contract.",
        "To authorize the smart contract to transfer tokens from your account."
      ],
      "correctAnswers": [3],
      "hint": "Consider how a smart contract gets permission to spend tokens from your account.",
      "explanation": "The `approve()` function allows a user to authorize a smart contract to withdraw tokens from their account up to a specified limit. This enables the smart contract to use `transferFrom()` to transfer tokens on behalf of the user.",
      "chapter": "Interchain Token Transfer"
    },
    "122": {
      "question": "Why are native tokens wrapped into ERC-20 tokens like wAVAX or wETH?",
      "options": [
        "To increase their transaction speed on the blockchain.",
        "To reduce the supply of the native token.",
        "To represent native assets as ERC-20 tokens for compatibility with DeFi applications.",
        "To convert them into stablecoins pegged to fiat currencies."
      ],
      "correctAnswers": [2],
      "hint": "Consider how wrapping affects interoperability within the EVM ecosystem.",
      "explanation": "Wrapping native tokens into ERC-20 tokens allows them to conform to the ERC-20 standard, making them compatible with decentralized applications, exchanges, and smart contracts that require ERC-20 tokens. This enhances interoperability and usability within the blockchain ecosystem.",
      "chapter": "Interchain Token Transfer"
    },
    "123": {
      "question": "Which of the following best describes the 'Lock & Mint' mechanism in asset bridging?",
      "options": [
        "Locking assets on the source blockchain and minting equivalent tokens on the target blockchain.",
        "Burning assets on both the source and target blockchains simultaneously.",
        "Using custodians to manage and transfer assets between blockchains.",
        "Releasing assets without the need for smart contracts or locking mechanisms."
      ],
      "correctAnswers": [0],
      "hint": "Consider how assets are secured on one chain and represented on another.",
      "explanation": "In the 'Lock & Mint' mechanism, assets are locked in a smart contract on the source blockchain, and an equivalent amount of wrapped tokens are minted on the target blockchain. This allows the asset's value to be transferred and used on a different blockchain.",
      "chapter": "Interchain Token Transfer"
    },
    "124": {
      "question": "Which type of smart contract exploit allows attackers to repeatedly withdraw funds before the contract's state is updated?",
      "options": [
        "Reentrancy Attacks",
        "Arithmetic Errors",
        "Logic Flaws",
        "Phishing Attacks"
      ],
      "correctAnswers": [0],
      "hint": "Consider exploits involving recursive calls to a contract.",
      "explanation": "Reentrancy attacks exploit a contract's ability to call itself before the initial function call is completed, allowing attackers to repeatedly withdraw funds before the contract's state is updated.",
      "chapter": "Interchain Token Transfer"
    },
    "125": {
      "question": "Which statement is true about token transfers in the Avalanche Interchain Token Transfer Design?",
      "options": [
        "Only ERC20 tokens can be transferred; native tokens are not supported.",
        "Transfers must involve the same token type on both home and remote chains.",
        "Any combination of ERC20 and native tokens can be transferred between home and remote chains.",
        "Token transfers require approval from network administrators."
      ],
      "correctAnswers": [2],
      "hint": "Consider the flexibility of token types allowed in transfers.",
      "explanation": "The Avalanche Interchain Token Transfer Design supports transferring tokens with any combination of ERC20 and native tokens between home and remote chains, including ERC20 to ERC20, ERC20 to Native, Native to ERC20, and Native to Native.",
      "chapter": "Interchain Token Transfer"
    },
    "126": {
      "question": "What is the purpose of the `_tokenMultiplier` in the `TokenRemote` contract when bridging assets between chains with different decimal systems?",
      "options": [
        "It adjusts the token amount to match the decimal system of the target chain by multiplying or dividing as necessary.",
        "It locks the tokens on the source chain before transfer.",
        "It handles the minting of new tokens on the target chain.",
        "It calculates the transaction fees for cross-chain transfers."
      ],
      "correctAnswers": [0],
      "hint": "Consider how token amounts are scaled between chains with different decimal places.",
      "explanation": "The `_tokenMultiplier` is used to scale the token amounts when transferring between chains with different decimal systems. It is calculated based on the difference in decimals between the home and remote tokens and ensures that the token value remains consistent across chains.",
      "chapter": "Interchain Token Transfer"
    },
    "127": {
      "question": "Can there be multiple TokenRemotes for a single TokenHome?",
      "hint": "Think about how tokens are transferred between chains and where they originate from.",
      "options": [
        "Yes",
        "No"
      ],
      "correctAnswers": [0],
      "explanation": "Yes, there can be multiple TokenRemotes for a single TokenHome. This allows the same token to be bridged to multiple chains, enabling cross-chain interoperability and use cases across different blockchain networks.",
      "chapter": "Interchain Token Transfer"
    },
    "301": {
      "question": "What is the role of a message in cross-blockchain communication?",
      "options": [
          "To process the data on the destination chain.",
          "To contain source, destination, and encoded data with a signature.",
          "To originate communication from the source chain.",
          "To validate the message authenticity on the source chain."
      ],
      "correctAnswers": [
          1
      ],
      "hint": "Messages carry essential information between chains, including source and destination details.",
      "explanation": "A message in cross-blockchain communication contains the source, destination, and encoded data along with a signature that guarantees its authenticity. This ensures that the information being transferred is accurate and can be trusted by the destination chain.",
      "chapter": "Interchain Messaging"
    },
    "302": {
      "question": "How does a multi-chain system achieve greater scalability compared to single-chain networks?",
      "options": [
          "By increasing the gas limit on a single chain.",
          "By running independent chains in parallel, allowing for combined throughput.",
          "By implementing more complex smart contracts on a single chain.",
          "By reducing the number of validators in the network."
      ],
      "correctAnswers": [
          1
      ],
      "hint": "Multi-chain systems utilize parallelism to enhance overall network performance.",
      "explanation": "A multi-chain system achieves greater scalability by running independent chains in parallel. This parallelism allows the network to handle a higher combined throughput of transactions, as each chain can process its own set of transactions simultaneously without being bottlenecked by a single chain's limitations.",
      "chapter": "Interchain Messaging"
    },
    "303": {
      "question": "Which Solidity functions are used for encoding and decoding data?",
      "options": [
          "serializeData() and deserializeData()",
          "encodeData() and decodeData()",
          "abi.encode() and abi.decode()",
          "bytes.encode() and bytes.decode()"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "These functions are part of Solidity's ABI encoding and decoding utilities.",
      "explanation": "In Solidity, `abi.encode()` is used to encode data into a bytes array, and `abi.decode()` is used to decode a bytes array back into its original types. These functions are essential for handling complex data structures in smart contracts.",
      "chapter": "Encoding & Decoding"
    },
    "304": {
      "question": "What is the name of the function used by a dApp to send a cross-chain message in the Interchain Messaging contract?",
      "options": [
          "sendCrossChainMessage()",
          "sendCrossMessage()",
          "initiateCrossChainCommunication()",
          "sendMessageCrossChain()"
      ],
      "correctAnswers": [
          0
      ],
      "hint": "This function is part of the ITeleporterMessenger interface used for sending messages between chains.",
      "explanation": "The `sendCrossChainMessage()` function is used by dApps to send cross-chain messages through the Interchain Messaging contract. It takes a `TeleporterMessageInput` struct as input, which includes details such as the destination chain ID, destination address, fee information, required gas limit, allowed relayers, and the encoded message.",
      "chapter": "Sending a Message"
    },
    "305": {
      "question": "Which interface must a contract implement to receive messages from the Interchain Messaging contract?",
      "options": [
          "ITeleporterMessenger",
          "ITeleporterReceiver",
          "ITeleporterSender",
          "IMessageHandler"
      ],
      "correctAnswers": [
          1
      ],
      "hint": "This interface defines the necessary function for receiving cross-chain messages.",
      "explanation": "To receive messages from the Interchain Messaging contract, a contract must implement the `ITeleporterReceiver` interface. This interface requires the implementation of the `receiveTeleporterMessage` function, which handles incoming messages.",
      "chapter": "Receiving a Message"
    },
    "306": {
      "question": "After encoding multiple values into a byte array using `abi.encode()`, what must you know to correctly decode the byte array in Solidity?",
      "options": [
          "The length of the byte array",
          "The contract's address",
          "The types and order of the encoded values",
          "The encoding algorithm used"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Decoding requires knowledge of the original data structure used during encoding.",
      "explanation": "To accurately decode a byte array in Solidity using `abi.decode()`, you must know the exact types and the order in which the values were encoded. This ensures that each segment of the byte array is interpreted correctly back into its original form.",
      "chapter": "Encoding & Decoding"
    },
    "307": {
      "question": "Why are `abi.encode()` functions called twice when encoding a function call with multiple parameters in a cross-chain message?",
      "options": [
          "To increase the security of the message.",
          "To pack the function name and its parameters into a single bytes array.",
          "To separate the message into two distinct byte arrays.",
          "To comply with the Teleporter contract requirements."
      ],
      "correctAnswers": [
          1
      ],
      "hint": "Encoding the function name alongside its parameters ensures proper identification and handling on the receiving end.",
      "explanation": "Calling `abi.encode()` twice allows you to first encode the function parameters and then encode the function name along with the encoded parameters. This ensures that the receiving contract can decode the function name to determine which internal function to execute with the provided parameters.",
      "chapter": "Encoding the Function Name and Parameters"
    },
    "308": {
      "question": "How does the TeleporterRegistry contract track different versions of the TeleporterMessenger contracts?",
      "options": [
          "By maintaining an array of contract addresses.",
          "By using separate variables for each version.",
          "By maintaining a mapping of version numbers to contract addresses.",
          "By storing all contract addresses in a single bytes array."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "The registry uses a key-value structure to associate versions with their corresponding contract addresses.",
      "explanation": "The TeleporterRegistry contract tracks different versions of the TeleporterMessenger contracts by maintaining a mapping of version numbers to their respective contract addresses. This allows cross-Avalanche L1 dApps to request either the latest version or a specific version of the TeleporterMessenger as needed.",
      "chapter": "How the ICM Registry works"
    },
   "309": {
      "question": "What is the purpose of the `Recover` algorithm in some signature schemes?",
      "options": [
          "To generate a key pair.",
          "To sign a message using the private key.",
          "To recover the public key from a message and its signature.",
          "To verify the integrity of a message."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "The `Recover` algorithm helps to retrieve the public key used to create a signature.",
      "explanation": "The `Recover` algorithm is used to retrieve the public key that corresponds to the private key used to create the signature for a given message. This allows for verification of the signature by matching the recovered public key with the sender's public key, ensuring the authenticity and integrity of the message.",
      "chapter": "Signature Schemes"
    },
    "310": {
      "question": "What is a key advantage of the BLS multi-signature scheme in blockchain applications?",
      "options": [
          "It requires only one private key for all participants.",
          "It eliminates the need for public keys.",
          "It uses symmetric cryptography for enhanced security.",
          "It supports signature and public key aggregation, resulting in compact signatures."
      ],
      "correctAnswers": [
          3
      ],
      "hint": "The BLS scheme is known for its ability to aggregate multiple signatures into one.",
      "explanation": "The BLS (Boneh-Lynn-Shacham) multi-signature scheme is highly efficient for blockchain applications due to its support for both signature and public key aggregation. This means multiple signatures can be compressed into a single short signature, and multiple public keys can be aggregated into one, reducing the storage and transmission overhead while maintaining security and integrity.",
      "chapter": "Signature Schemes"
    },
    "311": {
      "question": "What is the primary responsibility of the P-Chain in the Avalanche Network?",
      "options": [
          "Overseeing validator registration and staking operations for Avalanche L1s.",
          "Managing the execution of smart contracts.",
          "Handling transactions on the X-Chain.",
          "Facilitating the transfer of assets between different chains."
      ],
      "correctAnswers": [
          0
      ],
      "hint": "The P-Chain is responsible for validator and staking operations.",
      "explanation": "In the Avalanche Network, the P-Chain is responsible for validator and Avalanche L1-level operations. This includes the creation of new blockchains and Avalanche L1s, the addition of validators to Avalanche L1s, staking operations, and other platform-level operations. By registering BLS public keys and managing staking, the P-Chain ensures the security and functionality of the network.",
      "chapter": "P-Chain"
    },
    "312": {
      "question": "Which component is responsible for relaying interchain messages to the destination chain in the Avalanche Network?",
      "options": [
          "Warp Precompile",
          "Signature Verification",
          "AWM Relayer",
          "Message Initialization"
      ],
      "correctAnswers": [
          2
      ],
      "hint": "This component checks outgoing messages and delivers them to the destination chain.",
      "explanation": "The **AWM Relayer** is responsible for relaying interchain messages to the destination chain. It periodically checks the source Avalanche L1 for outgoing messages and delivers these by calling the Interchain Messaging contract on the destination Avalanche L1. This ensures that messages are efficiently transmitted between chains.",
      "chapter": "Data Flow of an Interchain Message"
    },
    "313": {
      "question": "How does the AWM Relayer in the Avalanche Network detect new outgoing messages?",
      "options": [
        "By periodically polling the source chain or being triggered by notifications.",
          "By receiving real-time alerts from validators.",
          "By scanning transaction receipts on the destination chain.",
          "By querying the latest block headers exclusively."
      ],
      "correctAnswers": [
          0
      ],
      "hint": "The AWM Relayer uses either a regular checking mechanism or event-based triggers.",
      "explanation": "The AWM Relayer detects new outgoing messages by either polling the source Avalanche L1 periodically for new messages or being triggered by notifications whenever a new outgoing message is detected by a node. This dual approach ensures that messages are efficiently picked up and relayed to the destination chain.",
      "chapter": "Message Pickup"
    },
    "314": {
      "question": "Why does the AWM Relayer not aggregate the BLS Public Keys off-chain and attach them to the message?",
      "options": [
          "Because aggregating off-chain would increase the message size significantly.",
          "To prevent the AWM Relayer from creating fraudulent public keys and signatures, ensuring security.",
          "Because the destination chain does not support off-chain aggregation.",
          "To reduce the computational load on the AWM Relayer."
      ],
      "correctAnswers": [
          1
      ],
      "hint": "Aggregating public keys off-chain could allow the relayer to fabricate signatures.",
      "explanation": "The AWM Relayer does not aggregate the BLS Public Keys off-chain and attach them to the message to prevent security vulnerabilities. If aggregation were done off-chain, the relayer could create fake public keys and signatures, compromising the authenticity and integrity of the messages. By requiring each validator on the destination chain to perform the aggregation, the system ensures that the aggregated public key accurately represents the signing validators, maintaining trust and security in the cross-chain communication process.",
      "chapter": "Signature Schemes"
    },
    "315": {
      "question": "What is the primary purpose of depositing ERC-20 tokens into the Interchain Messaging contract in the Avalanche Network?",
      "options": [
          "To pay for gas fees associated with transactions.",
          "To serve as collateral for staking operations.",
          "To incentivize the AWM Relayer by providing a reward for delivering messages.",
          "To lock tokens and prevent them from being transferred."
      ],
      "correctAnswers": [
          2
      ],
      "hint": "Depositing tokens serves as a financial incentive for relayers to perform their duties.",
      "explanation": "Depositing ERC-20 tokens into the Interchain Messaging contract acts as a reward mechanism for the AWM Relayer. When a relayer successfully delivers a message, they can claim the deposited tokens as compensation for their efforts in ensuring reliable cross-chain communication. This incentivization helps maintain the efficiency and security of the messaging system.",
      "chapter": "Fee Data Flow"
    },
    "316": {
      "question": "According to the Avalanche Network's fee incentivization model, how should the minimum fee amount be calculated to ensure that a Relayer makes at least a 10% profit?",
      "options": [
          "Fee = requiredGasLimit * gas_price_in_native_token",
          "Fee = (requiredGasLimit * gas_price_in_native_token) / 1.1",
          "Fee = requiredGasLimit + gas_price_in_native_token + native_token_price",
          "Fee = 1.1 * (requiredGasLimit * gas_price_in_native_token * native_token_price)"
      ],
      "correctAnswers": [
          3
      ],
      "hint": "The fee should cover the costs and provide additional profit to the Relayer.",
      "explanation": "To ensure the Relayer makes at least a 10% profit, the fee amount should be calculated as 1.1 times the cost. The cost is determined by multiplying the requiredGasLimit by the gas price in native tokens and the native token price. Therefore, the minimum fee should be 1.1 * (requiredGasLimit * gas_price_in_native_token * native_token_price).",
      "chapter": "Determining the Fee"
    }
  }
}